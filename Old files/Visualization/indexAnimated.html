<!DOCTYPE html>
<meta charset="utf-8">
<head>

</head>

<body>
<!--*****Include d3.js / d3plus.js / jQuery*****-->
<script src="http://www.d3plus.org/js/d3.js"></script>	
<script src="http://www.d3plus.org/js/d3plus.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>

<script>
//START OF "MAIN" FUNCTION
var a = [1,2,3,4,5];
	
//CALL THE VISUALIZE ARRAY FUNCTION
visualizeArray(a, "body", 50, 50);


function visualizeArray(array, vis_location, indexWidth, indexHeight){
	var needed_width = $(vis_location).width();
	var x_coord = 0;
	
	//CREATE THE CANVAS
	var canvas = d3.select(vis_location)
					.append("svg")
					.attr("width", needed_width)
					.attr("height", 2*indexHeight);
					
	//VISUALIZE THE ARRAY					
	for(var i = 0; i < array.length; ++i){
		x_coord = centerSVG(i, array.length, needed_width, indexWidth);
		animation(array, indexWidth, indexHeight, vis_location, canvas, x_coord, i);	
	}
	
	//TIMEOUT NEEDED SO THAT D3PLUS WORKS AFTER THE TRANSITION OF EACH INDEX OCCURS
	setTimeout(function(){	
		for(var j = 0; j < array.length; ++j){
			//USE D3PLUS TO OVERLAP THE DATA WITH THE CORRECT ARRAY INDEX
			d3plus.textwrap()
						.container(d3.select("#rectWrap" + j)) //Selects the ID of each SVG text object of the array and overlaps the text with the shape
						.resize(true)  //Automatically resizes the text to fit the shape
						.draw();
		}
	}, 1000);
}

function animation(array, indexWidth, indexHeight, location, canvas, x, cur_index){
	var neededWidth = $(location).width();
				
	//CREATE THE ARRAY INDEX
	var mySquare = canvas.selectAll("svg")  //Possibly remove mySquare
					.data([1])
					.enter()
						.append("rect")
						.attr("width", indexWidth)
						.attr("height", indexHeight)
						.attr("y", 25) //200
						.attr("x", 0)
						.attr("fill", backgroundColor(cur_index)) 
						.attr("class", "shape")
						.attr("stroke-width", 4)
						.attr("stroke", "black");
			
	//DISPLAY THE DATA INSIDE THE CURRENT INDEX
	var myText = canvas.selectAll("svg")
					.data([1]) 
					.enter()
						.append("text")
						.text(array[cur_index]) //Get the value located in the current array index
						.attr("class", "wrap")
						.attr("y", 25) //200
						.attr("x", 0)
						.attr("id", "rectWrap" + cur_index)  //The ID is used by d3plus to find what text needs
															//to be overlapped with an SVG shape. That is why
															//I'm adding the "+ i" (keeps the ID's different)
						.attr("text-anchor", "middle")
						.attr("opacity", 0);
	//MAKE THE TEXT INVISIBLE TO THE USER	
	//myText.transition()
		//	.attr("opacity", 1);
	//MAKES THE INDICES INVISIBLE TO THE USER AT THE BEGINNING
	mySquare.transition()
			.attr("opacity", 0);
	
		move_square(mySquare, myText, x, cur_index);	//Pass the calculated x-coordinate to move the square
	
}

//Calculates the correct position for each index to center the array in the specified location
function centerSVG(index, len, n_width, i_width){
	
	if(len % 2 == 0){  //EVEN NUMBER OF ELEMENTS IN THE ARRAY
	
		var leftTemp = n_width/2 - i_width; //Variable to hold the location of the
											//index directly left of the split
											
		var rightTemp = n_width/2; 			//Variable to hold the location of the
											//index directly right of the split
		
		if(index == len/2 - 1)  //LEFT SIDE OF THE "SPLIT"
			return (n_width/2) - i_width;
			
		else if(index == len/2) //RIGHT SIDE OF THE "SPLIT"
			return (n_width/2);
			
		else if(index < len/2 - 1){ //STRICTLY LEFT SIDE OF THE ARRAY
			
			 return leftTemp - ((len/2 - 1) - index) * i_width;
			
		}
		
		else{  //STRICTLY RIGHT SIDE OF THE ARRAY
			
			return rightTemp + (index - (len/2)) * i_width;
			
		}
	}
	
	else{			   //ODD NUMBER OF ELEMENTS IN ARRAY
		var tempMid = n_width/2 - (Math.floor(i_width/2)); //Variable to hold the location of the middle element

		if(index == Math.floor(len/2)) //ELEMENT GOES DIRECTLY IN THE MIDDLE
			return tempMid; //SUBTRACTION NOT ORIGINALLY THERE
		
		else if(index < Math.floor(len/2)){	//ELEMENT IS IN THE LEFT HALF OF THE ARRAY
			
			return tempMid - (Math.floor(len/2) - index)*i_width;
				
		}

		else{	//ELEMENT IS IN RIGHT HALF OF THE ARRAY
			
			return tempMid  +  (index-Math.floor(len/2))  *  i_width;
					//MIDDLE	  //Finds the correct	  //Spaces the indices out
								  //spot based on the     //so they're directly next
								  //index and how many    //to each other
								  //elements are in the
								  //right side of the array
		}
		
	}

}

//Moves the indices/data across the screen into their correct position
function move_square(square, text, x, i){
	
	square.transition()
			.duration(1000)
			.attr("x", x);	
	console.log("Index["+i+"] x = "+x);
	text.transition()
			.duration(1000)
			.attr("opacity", 1)
			.attr("x", x);
	console.log("Text["+i+"] x = "+x);
}

function backgroundColor(index){
	//Flip-flops the background color for even/odd indices
	if(index % 2 == 0)
		return("#123456")
											
	return("#124256")
}



</script>
</body>
</HTML>